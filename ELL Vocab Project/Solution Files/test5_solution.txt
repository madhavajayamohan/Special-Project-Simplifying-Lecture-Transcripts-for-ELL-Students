Alright class, today we’re going to focus on how we structure programs beyond just writing a few lines of code that run from top to bottom. 
You’ve already used control flow quite a bit, maybe without realizing it—especially when working with conditionals and loops. 

Control flow refers to the order in which individual statements, instructions, or function calls are executed in a program.
It determines how a program progresses based on conditions, loops, and function calls.

Conditionals are control flow statements that execute different blocks of code based on conditions. E.g
if condition:
    # Code executes if condition is true
elif another_condition:
    # Runs if previous condition was false
else:
    # Runs if none of the conditions are true"

Now we’re going to look at how to combine those ideas to build programs that are not only correct but also maintainable and easy to read.

Let’s begin with a simple problem: we want to build a small command-line tool that takes a list of numbers from the user and returns the largest even number. 
Straightforward, right? 
But here’s where we start thinking like computer scientists. 
Should we use for loops or while loops? 

For loops are loops that iterate over iterable objects like lists, tuples, and strings. E.g
for i in range(5):
    print(i)

While loops are loops that run as long as a condition is True. E.g.
x = 0
while x < 5:
    print(x)
    x += 1

Both would work, but one might be clearer in terms of intent. 
And if we decide to refactor the code later, readability becomes even more important.

As you work on problems like this, you’ll probably write a first version that works—and that’s great! 
But that first version might not be the cleanest. 
Refactoring helps us here. 

Code Refactoring is when we improve code readability, efficiency, or maintainability without changing its behavior.

For instance, if you find yourself writing the same few lines of code over and over, maybe that logic should go in a function. 
Or maybe your nested conditionals are too hard to read—flattening them out or splitting up your logic can make a big difference.

Conditionals are control flow statements that execute different blocks of code based on conditions. E.g
if condition:
    # Code executes if condition is true
elif another_condition:
    # Runs if previous condition was false
else:
    # Runs if none of the conditions are true"

Once we’ve got a function we’re happy with, we should test it. 
You’ve learned how to write tests with assert, but now let’s try writing doctests. 

Doctests are inline tests written in the docstring of a function that demonstrate expected behavior.
A docstring is a special multiline string inside a function that describes its purpose, parameters, return value, and other details.

When someone reads your function’s docstring and sees an example call right there, it helps both as documentation and verification. 
And if it fails, you immediately know something’s off.

Let’s take a quick detour into data structures. 
In this assignment, we’ve been using lists, but maybe you’ll hit a point where you want to keep track of more structured information—like user input history or statistics. 

Lists are mutable ordered collections of values, created with square brackets. E.g.
lst = [1, 2, 3]

That’s a good place to introduce dictionaries. 

Dictionaries are key-value pairs stored in curly braces {}. E.g
d = {'name': 'Alice', 'age': 25}

You can map string keys like "even_count" to their values, which helps organize your data better as the program grows.

Later this week, we’ll also look at how sorting fits into things. 

Sorting refers to a common concept in programming where we want to arrange elements according to a certain order.
Common sorting algorithms include merge sort and quick sort.

Suppose you wanted to return not just the largest even number, but the top three even numbers. 
Sorting your list first could make that task a lot easier.

And for those of you curious about performance: as we start comparing different solutions, we’ll lightly touch on algorithmic complexity. 

The complexity of an algorithim refers to the efficiency of an algorithm in terms of time and space, often analyzed using Big-O notation.

Knowing whether your sort or loop takes linear vs quadratic time can be helpful, especially when you move to larger input sizes.

Finally, some of you have asked about organizing larger programs. 
That’s where we’ll eventually introduce OOP, but for now, just focus on using functions to break down tasks and keep your logic clean.

Object Oriented Programming (OOP) is a parogramming paradigm that models problems using classes and objects.


Alright, that’s it for today. 
Make sure to review your assignment’s control flow and try adding at least one doctest to each function. 
Next class, we’ll talk about how to validate user input and build simple menus using loops and conditionals.